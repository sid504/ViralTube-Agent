import { ScriptData } from "../types";

let tokenClient: any;
let accessToken: string | null = null;

export const initGoogleAuth = (clientId: string, onTokenCallback: (token: string) => void) => {
  if (typeof window === 'undefined') return;
  
  if (!(window as any).google) {
    console.error("Google Identity Services script not loaded");
    return;
  }

  tokenClient = (window as any).google.accounts.oauth2.initTokenClient({
    client_id: clientId,
    scope: 'https://www.googleapis.com/auth/youtube.upload https://www.googleapis.com/auth/youtube.readonly https://www.googleapis.com/auth/youtube.force-ssl',
    callback: (response: any) => {
      if (response.access_token) {
        accessToken = response.access_token;
        onTokenCallback(response.access_token);
      }
    },
  });
};

export const requestAuth = () => {
  if (!tokenClient) throw new Error("Auth not initialized. Set Client ID first.");
  tokenClient.requestAccessToken();
};

export const getChannelInfo = async (token: string) => {
  const response = await fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true', {
    headers: { 'Authorization': `Bearer ${token}` }
  });
  const data = await response.json();
  if (data.items && data.items.length > 0) {
    const snippet = data.items[0].snippet;
    return {
      name: snippet.title,
      thumbnail: snippet.thumbnails.default.url,
      channelId: data.items[0].id
    };
  }
  return null;
};

const dataURLtoBlob = (dataurl: string) => {
  const arr = dataurl.split(',');
  const mime = arr[0].match(/:(.*?);/)![1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while(n--){
      u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], {type:mime});
};

/**
 * Robust YouTube Upload using Resumable Protocol
 * Essential for 10+ minute videos which fail in multipart mode.
 */
export const uploadVideoToYouTube = async (
  videoBlobUrl: string,
  thumbnailBase64: string | null,
  script: ScriptData,
  token: string,
  onProgress: (percent: number) => void
): Promise<string> => {
  
  const videoBlob = await fetch(videoBlobUrl).then(r => r.blob());
  
  const metadata = {
    snippet: {
      title: script.title.substring(0, 100),
      description: `${script.description}\n\n#SanatanaDharma #TeluguHistory #Mythology\n\nGenerated by ViralTube AI.`,
      tags: script.tags,
      categoryId: "28", // Tech/Edu
      defaultLanguage: "te", // Set to Telugu
      defaultAudioLanguage: "te"
    },
    status: {
      privacyStatus: "public",
      selfDeclaredMadeForKids: false
    }
  };

  onProgress(5);

  // STEP 1: Initiate Resumable Upload Session
  const initiateResponse = await fetch('https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json; charset=UTF-8',
      'X-Upload-Content-Length': videoBlob.size.toString(),
      'X-Upload-Content-Type': videoBlob.type
    },
    body: JSON.stringify(metadata)
  });

  if (!initiateResponse.ok) {
    const error = await initiateResponse.text();
    throw new Error(`Failed to initiate upload: ${error}`);
  }

  const uploadUrl = initiateResponse.headers.get('Location');
  if (!uploadUrl) throw new Error("No upload URL received from YouTube");

  onProgress(10);

  // STEP 2: Upload the actual binary data
  // Using XMLHttpRequest for better progress tracking during the large upload
  const videoId = await new Promise<string>((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('PUT', uploadUrl);
    xhr.setRequestHeader('Authorization', `Bearer ${token}`);
    xhr.setRequestHeader('Content-Type', videoBlob.type);

    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable) {
        const percent = Math.round((e.loaded / e.total) * 70) + 10;
        onProgress(percent);
      }
    };

    xhr.onload = () => {
      if (xhr.status === 200 || xhr.status === 201) {
        const response = JSON.parse(xhr.responseText);
        resolve(response.id);
      } else {
        reject(new Error(`Upload failed with status ${xhr.status}: ${xhr.responseText}`));
      }
    };

    xhr.onerror = () => reject(new Error("Network error during video upload."));
    xhr.send(videoBlob);
  });

  onProgress(85);

  // STEP 3: Set Thumbnail
  if (thumbnailBase64 && videoId) {
    try {
      const thumbBlob = dataURLtoBlob(thumbnailBase64);
      const thumbXhr = new XMLHttpRequest();
      thumbXhr.open('POST', `https://www.googleapis.com/upload/youtube/v3/thumbnails/set?videoId=${videoId}&uploadType=media`);
      thumbXhr.setRequestHeader('Authorization', `Bearer ${token}`);
      thumbXhr.setRequestHeader('Content-Type', 'image/png');
      
      thumbXhr.onload = () => onProgress(100);
      thumbXhr.send(thumbBlob);
    } catch (e) {
      console.warn("Thumbnail upload failed", e);
      onProgress(100);
    }
  } else {
    onProgress(100);
  }

  return videoId;
};